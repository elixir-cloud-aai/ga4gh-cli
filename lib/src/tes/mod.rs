pub mod models;
use crate::transport::Transport;
use reqwest::Response;
use serde::ser;
use serde_json::json;
use crate::serviceinfo::ServiceInfo;
use crate::configuration::Configuration;
use crate::tes::models::TesTask;
use crate::tes::models::TesCreateTaskResponse;
use crate::tes::models::TesState;

// ***
// should TES.create return Task? which in turn can do status() and other existing-task-related stuff
// instead of TES.status(task_id) we could do task.status()
pub struct Task {
    id: String,
}

impl Task {
    pub fn new(id: String) -> Self {
        Task {
            id: id,
        }
    }

    pub fn status(&self) -> Result<TesState, Box<dyn std::error::Error>> {
        Ok(TesState::Running)
    }
}

pub struct TES {
    config: Configuration,
    service_info: ServiceInfo,
    transport: Transport,
}
// *** see question above

impl TES {
    pub async fn new(config: &Configuration) -> Self {
    let transport = &Transport::new(config);
    let service_info = &ServiceInfo::new(transport.clone());
    let _resp = service_info.get_service_info().await;
    // assert_eq!(_resp.name, "TES");
    TES {
        config: config.clone(),
        transport: transport.clone(),
        service_info: service_info.clone(),
    }
}

    pub async fn create(&self, task: TesTask/*, params: models::TesTask*/) -> Result<TesCreateTaskResponse, Box<dyn std::error::Error>> {
        // todo: version in url based on serviceinfo or user config
        let url = format!("{}/ga4gh/tes/v1/tasks", self.config.base_path);
        let response = self.transport.post(&url, json!(task)).await;
        match response {
            Ok(response_body) => {
                match serde_json::from_str::<TesCreateTaskResponse>(&response_body) {
                    Ok(tes_create_task_response) => Ok(tes_create_task_response),
                    Err(e) => {
                        log::error!("Failed to deserialize response: {}", e);
                        Err("Failed to deserialize response".into())
                    },
                }
            },
            Err(e) => {
                log::error!("Error: {}", e);
                Err(e)
            },
        }
    }

    // pub async fn status(&self, task: &TesCreateTaskResponse) -> Result<TesState, Box<dyn std::error::Error>> {
    pub async fn status(&self, task_id: &str, view: &str) -> Result<TesState, Box<dyn std::error::Error>> {
        // ?? move to Task::status()
        // todo: version in url based on serviceinfo or user config
        let url = format!("{}/ga4gh/tes/v1/tasks/{}", self.config.base_path, task_id);
        let params = [("view", view)];
        let params_value = serde_json::json!(params);
        let response = self.transport.get(&url, Some(params_value)).await;
        match response {
            Ok(response_body) => {
                match serde_json::from_str::<TesState>(&response_body) {
                    Ok(tes_state) => Ok(tes_state),
                    Err(e) => {
                        log::error!("Failed to deserialize response: {}", e);
                        Err("Failed to deserialize response".into())
                    },
                }
            },
            Err(e) => {
                log::error!("Error: {}", e);
                Err(e)
            },
        }
    }

    // TODO: pub fn list()
}

#[cfg(test)]
mod tests {
    use crate::tes::TES;
    use crate::configuration::Configuration;
    use crate::tes::models::TesTask;
    use crate::tes::models::TesCreateTaskResponse;

    async fn create_task() -> Result<String, Box<dyn std::error::Error>> {
        let mut config = Configuration::default();
        config.set_base_path("http://localhost:8080"); // expecting TES/Funnel, TODO autorun
        let tes = TES::new(&config).await;
    
        let task_json = std::fs::read_to_string("./lib/sample/grape.tes").expect("Unable to read file");
        let task: TesTask = serde_json::from_str(&task_json).expect("JSON was not well-formatted");
    
        let task = tes.create(task).await?;
        Ok(task.id)
    }

    #[tokio::test]
    async fn test_task_create() {
        env_logger::init();
    
        let task = create_task().await.expect("Failed to create task");
        assert!(!task.is_empty(), "Task ID should not be empty"); // doube check if it's a correct assertion
    }

    #[tokio::test]
    async fn test_task_status() {
        env_logger::init();
    
        let task = create_task().await.expect("Failed to create task");
        // Now use task to get the task status...
        // todo: assert_eq!(task.status().await, which status?);
    }
}

// not sure if we need the code bellow, it was autogenerated by openapi-generator as i understand
// struct for typed errors of method [`get_service_info`]
// #[derive(Debug, Clone, Serialize, Deserialize)]
// #[serde(untagged)]
// pub enum GetServiceInfoError {
//     UnknownValue(serde_json::Value),
// }
// #[derive(Debug, Clone)]
// pub struct ResponseContent<T> {
//     pub status: reqwest::StatusCode,
//     pub content: String,
//     pub entity: Option<T>,
// }

// #[derive(Debug)]
// pub enum Error<T> {
//     Reqwest(reqwest::Error),
//     Serde(serde_json::Error),
//     Io(std::io::Error),
//     ResponseError(ResponseContent<T>),
// }

// impl <T> fmt::Display for Error<T> {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         let (module, e) = match self {
//             Error::Reqwest(e) => ("reqwest", e.to_string()),
//             Error::Serde(e) => ("serde", e.to_string()),
//             Error::Io(e) => ("IO", e.to_string()),
//             Error::ResponseError(e) => ("response", format!("status code {}", e.status)),
//         };
//         write!(f, "error in {}: {}", module, e)
//     }
// }

// impl <T: fmt::Debug> error::Error for Error<T> {
//     fn source(&self) -> Option<&(dyn error::Error + 'static)> {
//         Some(match self {
//             Error::Reqwest(e) => e,
//             Error::Serde(e) => e,
//             Error::Io(e) => e,
//             Error::ResponseError(_) => return None,
//         })
//     }
// }

// impl <T> From<reqwest::Error> for Error<T> {
//     fn from(e: reqwest::Error) -> Self {
//         Error::Reqwest(e)
//     }
// }

// impl <T> From<serde_json::Error> for Error<T> {
//     fn from(e: serde_json::Error) -> Self {
//         Error::Serde(e)
//     }
// }

// impl <T> From<std::io::Error> for Error<T> {
//     fn from(e: std::io::Error) -> Self {
//         Error::Io(e)
//     }
// }

// pub fn urlencode<T: AsRef<str>>(s: T) -> String {
//     ::url::form_urlencoded::byte_serialize(s.as_ref().as_bytes()).collect()
// }

// pub fn parse_deep_object(prefix: &str, value: &serde_json::Value) -> Vec<(String, String)> {
//     if let serde_json::Value::Object(object) = value {
//         let mut params = vec![];

//         for (key, value) in object {
//             match value {
//                 serde_json::Value::Object(_) => params.append(&mut parse_deep_object(
//                     &format!("{}[{}]", prefix, key),
//                     value,
//                 )),
//                 serde_json::Value::Array(array) => {
//                     for (i, value) in array.iter().enumerate() {
//                         params.append(&mut parse_deep_object(
//                             &format!("{}[{}][{}]", prefix, key, i),
//                             value,
//                         ));
//                     }
//                 },
//                 serde_json::Value::String(s) => params.push((format!("{}[{}]", prefix, key), s.clone())),
//                 _ => params.push((format!("{}[{}]", prefix, key), value.to_string())),
//             }
//         }

//         return params;
//     }

//     unimplemented!("Only objects are supported with style=deepObject")
// }
